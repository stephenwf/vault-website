{
  "title": "Loading manifests",
  "folder": "vault",
  "body": {
    "raw": "\n### Loading using URLs\nThere are 3 APIs available for loading resources.\n\n* Load\n* Load manifest\n* Load collection\n\nThese are functionally identical, but the [Typescript](/docs/types) types returned are more specific for `loadManifest`\nand `loadCollection`. The remaining examples will all use `.loadManifest()`.\n\nWhen you call a load function a promise will always be returned, even if the data is cached and available. \n\n```js\nimport { Vault } from '@iiif/vault';\n\nconst vault = new Vault();\nvault.loadManifest(`https://example.org/manifest`).then(manifest => {\n    // Do something with manifest.\n});\n```\n\nIf you are using in a context that supports\n\n#### Status object\nWhen you call a loader a status object will be created.\n\n```typescript\ninterface ResourceStatus {\n  loadingState: 'RESOURCE_ERROR' | 'RESOURCE_LOADING' | 'RESOURCE_READY';\n  uriMismatch: boolean;\n  requestUri: string;\n  resourceUri: string;\n  error?: string;\n}\n```\n\nAs soon as you call a load function the resource will transition to `RESOURCE_LOADING` if it has not already been\nfetched. It will then either progress to `RESOURCE_ERROR` with `status.error` populated with the text representation of\nthe exception, or it will progress to `RESOURCE_READY`.\n\nIf the URL requested does not match the `@id` or `id` in the returned JSON then a mapping will be kept. In the status \nthere are 2 urls noted.\n* `requestUri` - the string passed to `load()` and the one requested\n* `resourceUri` - the Identifier present in the resource  (`id` or `@id`)\n* `uriMismatch` - True if the two Uris above do not match\n\nInternally this allows vault to get a handle on the Manifest using either the URI or the Identifier of the resource. For\nall internal maps the Identifier is preferred, not the Uri.\n\nCurrently, there is no way to \"evict\" a resource from Vault. \n\nTwo helpers relating to status\n\n* `vault.requestStatus(id)` - returns the current status, or undefined\n* `vault.ensureLoaded(id)` - similar to load, but does not return anything. Only calls fetcher if there is no status. Additionally it will not retry errors. Useful for `prefetch` or similar scenarios.\n\n```js\nconst status = vault.requestStatus('https://example.org/manifest');\nif (status) {\n  switch (status.loadingState) {\n    case 'RESOURCE_READY':\n    // ...\n    case 'RESOURCE_LOADING':\n    // ...\n    case 'RESOURCE_ERROR':\n    // ...\n  }\n}\n```\n\n#### Upgrading resources\n\nWhen you load a IIIF resource into Vault, a check will be made to see if conforms to the IIIF Presentation 2.1 specification. If\nthe v2 context is found, the IIIF resource will be sent through an upgrade path. This aims to upgrade all 2.1 resource to IIIF\nPresentation 3.0 and in the future will upgrade to whichever is the latest version. You can read in detail how this works in the [Upgrading](/docs/parser/upgrading) section.\n\nWhen reading IIIF resources loaded by vault, you can safely assume that they will be well-formed Presentation 3. This should\nreduce that code required to support features while still supporting as wide a range of IIIF as possible.\n\n<!-- this is paragraph rough -->\nCurrently, if you load Presentation 3 resources into Vault, no attempt will be made to fix any common mistakes or irregular IIIF. In the\nfuture this will change, with the current behaviour being an optional [Strict Mode](/docs/vault/roadmap#strict-mode) and a new compatibility mode will be introduced. This\nwill allow Vault and the associated tools and types to be used as a way to validate IIIF for those implementing it. If Vault only\nhad this loose/compatibility mode it could run the risk of incorrectly validating bugs from those creating IIIF implementations\nthemselves.\n\n### Providing JSON\n\nThere are some cases where you may want to load IIIF JSON before it goes to Vault. This could be for Authenticated resources\nor resources that may not have been saved yet - or may not ever be saved. For each of the `load()` methods on Vault there is \nan optional second argument for the JSON to be provided.\n\n```js\nconst manifest = await vault.load('https://example.org/manifest-1', {\n    '@context': 'http://iiif.io/api/presentation/3/context.json'\n    id: 'https://example.org/manifest-1',\n    type: 'Manifest',\n    ... \n})\n```\n\nThis will still return a promise, for consistency. Check the [advanced](/docs/vault/advanced) docs if you need to \nload data into Vault synchronously.\n\n### Node JS\n\nWhen calling a load function in the browser, the native `fetch()` api is used. You will need to provide a polyfill for this\nif you need to target browser that do not support this.\n\nStarting from Node 18+ you can use the built-in `fetch()` api. Prior versions of Node will include the `node-fetch` library\nfor fetching resources.\n\n### Custom fetchers\n\nWhen you create a Vault you can optionally pass in a custom fetcher function.\n```js\nimport { Vault } from '@iiif/vault';\n\nconst customVault = new Vault({\n  customFetcher: async (url) => {\n    // custom loading logic.\n  }, \n})\n```\n\nThis can either return a promise or just the javascript object for the resource.\n\nIf you need to completely replace the fetching mechanism, but retain the loading statuses provided by Vault, you can create\na custom loader. This is included as a separate export.\n\n```js\nimport { createFetchHelper } from '@iiif/vault/utility';\n\nconst vault = new Vault();\n\nconst newFetch = createFetchHelper(vault.store, async (url, options) => {\n    // custom logic..\n});\n\nawait newFetch('htts://example.org/manifest-1', { some: 'custom option' });\n```\n\nThis custom fetcher will be tied to the store you created. Like the custom fetcher in Vault it should return the loaded\nresource as a JS object. You can create as many of these custom fetch helpers for a single vault. Creating these fetchers\nwill **not** replace the `vault.load()` functions, they continue to work. \n\n\n### CORS\n\nIn the browser, `fetch()` is used without any arguments or CORS settings. This may be a common use-case for overwriting\nthe default fetcher if you required cookies to be sent to authenticate resources. Vault will not retry resources that run\ninto CORS errors. The most common cause of CORS errors is 5xx errors with Vault.\n",
    "html": "<h3>Loading using URLs</h3>\n<p>There are 3 APIs available for loading resources.</p>\n<ul>\n<li>Load</li>\n<li>Load manifest</li>\n<li>Load collection</li>\n</ul>\n<p>These are functionally identical, but the <a href=\"/docs/types\">Typescript</a> types returned are more specific for <code>loadManifest</code>\nand <code>loadCollection</code>. The remaining examples will all use <code>.loadManifest()</code>.</p>\n<p>When you call a load function a promise will always be returned, even if the data is cached and available.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Vault</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@iiif/vault'</span>;\n\n<span class=\"hljs-keyword\">const</span> vault = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Vault</span>();\nvault.<span class=\"hljs-title function_\">loadManifest</span>(<span class=\"hljs-string\">`https://example.org/manifest`</span>).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">manifest</span> =></span> {\n    <span class=\"hljs-comment\">// Do something with manifest.</span>\n});\n</code></pre>\n<p>If you are using in a context that supports</p>\n<h4>Status object</h4>\n<p>When you call a loader a status object will be created.</p>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">ResourceStatus</span> {\n  <span class=\"hljs-attr\">loadingState</span>: <span class=\"hljs-string\">'RESOURCE_ERROR'</span> | <span class=\"hljs-string\">'RESOURCE_LOADING'</span> | <span class=\"hljs-string\">'RESOURCE_READY'</span>;\n  <span class=\"hljs-attr\">uriMismatch</span>: <span class=\"hljs-built_in\">boolean</span>;\n  <span class=\"hljs-attr\">requestUri</span>: <span class=\"hljs-built_in\">string</span>;\n  <span class=\"hljs-attr\">resourceUri</span>: <span class=\"hljs-built_in\">string</span>;\n  error?: <span class=\"hljs-built_in\">string</span>;\n}\n</code></pre>\n<p>As soon as you call a load function the resource will transition to <code>RESOURCE_LOADING</code> if it has not already been\nfetched. It will then either progress to <code>RESOURCE_ERROR</code> with <code>status.error</code> populated with the text representation of\nthe exception, or it will progress to <code>RESOURCE_READY</code>.</p>\n<p>If the URL requested does not match the <code>@id</code> or <code>id</code> in the returned JSON then a mapping will be kept. In the status\nthere are 2 urls noted.</p>\n<ul>\n<li><code>requestUri</code> - the string passed to <code>load()</code> and the one requested</li>\n<li><code>resourceUri</code> - the Identifier present in the resource  (<code>id</code> or <code>@id</code>)</li>\n<li><code>uriMismatch</code> - True if the two Uris above do not match</li>\n</ul>\n<p>Internally this allows vault to get a handle on the Manifest using either the URI or the Identifier of the resource. For\nall internal maps the Identifier is preferred, not the Uri.</p>\n<p>Currently, there is no way to \"evict\" a resource from Vault.</p>\n<p>Two helpers relating to status</p>\n<ul>\n<li><code>vault.requestStatus(id)</code> - returns the current status, or undefined</li>\n<li><code>vault.ensureLoaded(id)</code> - similar to load, but does not return anything. Only calls fetcher if there is no status. Additionally it will not retry errors. Useful for <code>prefetch</code> or similar scenarios.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> status = vault.<span class=\"hljs-title function_\">requestStatus</span>(<span class=\"hljs-string\">'https://example.org/manifest'</span>);\n<span class=\"hljs-keyword\">if</span> (status) {\n  <span class=\"hljs-keyword\">switch</span> (status.<span class=\"hljs-property\">loadingState</span>) {\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'RESOURCE_READY'</span>:\n    <span class=\"hljs-comment\">// ...</span>\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'RESOURCE_LOADING'</span>:\n    <span class=\"hljs-comment\">// ...</span>\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'RESOURCE_ERROR'</span>:\n    <span class=\"hljs-comment\">// ...</span>\n  }\n}\n</code></pre>\n<h4>Upgrading resources</h4>\n<p>When you load a IIIF resource into Vault, a check will be made to see if conforms to the IIIF Presentation 2.1 specification. If\nthe v2 context is found, the IIIF resource will be sent through an upgrade path. This aims to upgrade all 2.1 resource to IIIF\nPresentation 3.0 and in the future will upgrade to whichever is the latest version. You can read in detail how this works in the <a href=\"/docs/parser/upgrading\">Upgrading</a> section.</p>\n<p>When reading IIIF resources loaded by vault, you can safely assume that they will be well-formed Presentation 3. This should\nreduce that code required to support features while still supporting as wide a range of IIIF as possible.</p>\n<p>Currently, if you load Presentation 3 resources into Vault, no attempt will be made to fix any common mistakes or irregular IIIF. In the\nfuture this will change, with the current behaviour being an optional <a href=\"/docs/vault/roadmap#strict-mode\">Strict Mode</a> and a new compatibility mode will be introduced. This\nwill allow Vault and the associated tools and types to be used as a way to validate IIIF for those implementing it. If Vault only\nhad this loose/compatibility mode it could run the risk of incorrectly validating bugs from those creating IIIF implementations\nthemselves.</p>\n<h3>Providing JSON</h3>\n<p>There are some cases where you may want to load IIIF JSON before it goes to Vault. This could be for Authenticated resources\nor resources that may not have been saved yet - or may not ever be saved. For each of the <code>load()</code> methods on Vault there is\nan optional second argument for the JSON to be provided.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> manifest = <span class=\"hljs-keyword\">await</span> vault.<span class=\"hljs-title function_\">load</span>(<span class=\"hljs-string\">'https://example.org/manifest-1'</span>, {\n    <span class=\"hljs-string\">'@context'</span>: <span class=\"hljs-string\">'http://iiif.io/api/presentation/3/context.json'</span>\n    <span class=\"hljs-attr\">id</span>: <span class=\"hljs-string\">'https://example.org/manifest-1'</span>,\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'Manifest'</span>,\n    ... \n})\n</code></pre>\n<p>This will still return a promise, for consistency. Check the <a href=\"/docs/vault/advanced\">advanced</a> docs if you need to\nload data into Vault synchronously.</p>\n<h3>Node JS</h3>\n<p>When calling a load function in the browser, the native <code>fetch()</code> api is used. You will need to provide a polyfill for this\nif you need to target browser that do not support this.</p>\n<p>Starting from Node 18+ you can use the built-in <code>fetch()</code> api. Prior versions of Node will include the <code>node-fetch</code> library\nfor fetching resources.</p>\n<h3>Custom fetchers</h3>\n<p>When you create a Vault you can optionally pass in a custom fetcher function.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Vault</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@iiif/vault'</span>;\n\n<span class=\"hljs-keyword\">const</span> customVault = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Vault</span>({\n  <span class=\"hljs-attr\">customFetcher</span>: <span class=\"hljs-keyword\">async</span> (url) => {\n    <span class=\"hljs-comment\">// custom loading logic.</span>\n  }, \n})\n</code></pre>\n<p>This can either return a promise or just the javascript object for the resource.</p>\n<p>If you need to completely replace the fetching mechanism, but retain the loading statuses provided by Vault, you can create\na custom loader. This is included as a separate export.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { createFetchHelper } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@iiif/vault/utility'</span>;\n\n<span class=\"hljs-keyword\">const</span> vault = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Vault</span>();\n\n<span class=\"hljs-keyword\">const</span> newFetch = <span class=\"hljs-title function_\">createFetchHelper</span>(vault.<span class=\"hljs-property\">store</span>, <span class=\"hljs-keyword\">async</span> (url, options) => {\n    <span class=\"hljs-comment\">// custom logic..</span>\n});\n\n<span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">newFetch</span>(<span class=\"hljs-string\">'htts://example.org/manifest-1'</span>, { <span class=\"hljs-attr\">some</span>: <span class=\"hljs-string\">'custom option'</span> });\n</code></pre>\n<p>This custom fetcher will be tied to the store you created. Like the custom fetcher in Vault it should return the loaded\nresource as a JS object. You can create as many of these custom fetch helpers for a single vault. Creating these fetchers\nwill <strong>not</strong> replace the <code>vault.load()</code> functions, they continue to work.</p>\n<h3>CORS</h3>\n<p>In the browser, <code>fetch()</code> is used without any arguments or CORS settings. This may be a common use-case for overwriting\nthe default fetcher if you required cookies to be sent to authenticate resources. Vault will not retry resources that run\ninto CORS errors. The most common cause of CORS errors is 5xx errors with Vault.</p>"
  },
  "_id": "docs/01-vault/01-loading-manifests.md",
  "_raw": {
    "sourceFilePath": "docs/01-vault/01-loading-manifests.md",
    "sourceFileName": "01-loading-manifests.md",
    "sourceFileDir": "docs/01-vault",
    "contentType": "markdown",
    "flattenedPath": "docs/01-vault/01-loading-manifests"
  },
  "type": "Docs",
  "filename": "loading-manifests",
  "url": "/docs/vault/loading-manifests"
}